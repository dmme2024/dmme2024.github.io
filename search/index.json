[{"content":"设计图\nMapperProxyFactory为每一个IDao接口生成一个代理类MapperProxy，通过代理类执行。\nMapperProxy类\npublic class MapperProxy\u0026lt;T\u0026gt; implements InvocationHandler, Serializable { private static final long serialVersionUID = 5808394150170125347L; private Map\u0026lt;String, String\u0026gt; sqlSession; // sql语句与对应的方法 private final Class\u0026lt;T\u0026gt; mapperInterface; // 代理的接口 public MapperProxy(Map\u0026lt;String, String\u0026gt; sqlSession, Class\u0026lt;T\u0026gt; mapperInterface) { this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; } @Override // 代理执行的方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 非代理类 if (Object.class.equals(method.getDeclaringClass())){ return method.invoke(this, args); } else{ return \u0026#34;你的被代理了！\u0026#34; + sqlSession.get(mapperInterface.getName() + \u0026#34;.\u0026#34; + method.getName()); } } } MapperProxy通过实现InvocationHandler接口的invoke，能够执行接口对应的sql语句。\nMapperProxyFactory类\npublic class MapperProxyFactory\u0026lt;T\u0026gt; { private final Class\u0026lt;T\u0026gt; mapperInterface; public MapperProxyFactory(Class\u0026lt;T\u0026gt; mapperInterface) { this.mapperInterface = mapperInterface; } // 创建代理的实例 public T newInstance(Map\u0026lt;String, String\u0026gt; sqlSession) { final MapperProxy\u0026lt;T\u0026gt; mapperProxy = new MapperProxy\u0026lt;\u0026gt;(sqlSession, mapperInterface); return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[]{mapperInterface}, mapperProxy); } } newInstance为IDao接口创建一个MapperProxy实例。\n@Test public void test_MapperProxyFactory() { // 创建代理类工厂 MapperProxyFactory\u0026lt;IUserDao\u0026gt; factory = new MapperProxyFactory\u0026lt;\u0026gt;(IUserDao.class); Map\u0026lt;String, String\u0026gt; sqlSession = new HashMap\u0026lt;\u0026gt;(); sqlSession.put(\u0026#34;com.test.mybatis.test.dao.IUserDao.queryUserName\u0026#34;, \u0026#34;模拟执行 Mapper.xml 中语句，查询用户名\u0026#34;); // 类似mybatis xml中的sql语句 sqlSession.put(\u0026#34;com.test.mybatis.test.dao.IUserDao.queryUserAge\u0026#34;, \u0026#34;模拟执行Mapper.xml中语句，查询用户年龄\u0026#34;); IUserDao userDao = factory.newInstance(sqlSession); // 创建IUserDao的代理类MapperProxy String res = userDao.queryUserName(\u0026#34;10001\u0026#34;); // 执行方法 : 代理类通过InvocationHandler 执行 logger.info(\u0026#34;测试结果：{}\u0026#34;, res); } 分析\n代理模式：原对象Mapper接口，MapperProxy代理实现具体方法，将接口定义和执行方法解耦； 工厂模式：MapperProxyFactory代理工厂，原Mapper接口没有具体的实现类，MapperProxyFactory为其生成代理实例； ","date":"2022-06-08T00:22:03+08:00","permalink":"https://www.dmme2024.xyz/p/%E6%89%8B%E6%92%B8mybatis-01-%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E6%98%A0%E5%B0%84%E5%99%A8%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82/","title":"手撸Mybatis-01-创建简单映射器代理工厂"},{"content":"设计图\n增加MapperRegistry，扫描包，为每一个接口注册一个ProxyFactory\nSqlSession、SqlSessionFactory以及默认的实现类，提供SqlSession服务\nMapperRegistry类\npublic class MapperRegistry { // 存储已经注册的mapper接口的proxy工厂 // 使用时，每个线程都创建一个接口的proxy实例？？？ private final Map\u0026lt;Class\u0026lt;?\u0026gt;,MapperProxyFactory\u0026lt;?\u0026gt;\u0026gt; knownMappers = new HashMap\u0026lt;\u0026gt;(); // 获取对应的mapper proxy实例 public \u0026lt;T\u0026gt; T getMapper(Class\u0026lt;T\u0026gt; type, SqlSession sqlSession) { final MapperProxyFactory\u0026lt;T\u0026gt; mapperProxyFactory = (MapperProxyFactory\u0026lt;T\u0026gt;) knownMappers.get(type); if (mapperProxyFactory == null){ throw new RuntimeException(\u0026#34;Type\u0026#34; + type + \u0026#34;is not known to the MapperRegistry.\u0026#34;); } try { return mapperProxyFactory.newInstance(sqlSession); } catch (Exception e){ throw new RuntimeException(\u0026#34;Error getting mapper instance.Cause \u0026#34; + e, e); } } // 注册到mapper里面，是将代理工厂注册上去 public \u0026lt;T\u0026gt; void addMapper(Class\u0026lt;T\u0026gt; type){ if (type.isInterface()) { if (hasMapper(type)) { throw new RuntimeException(\u0026#34;Type \u0026#34; + type + \u0026#34; is already known to the MapperRegistry.\u0026#34;); } // 注册映射器代理工厂 knownMappers.put(type, new MapperProxyFactory\u0026lt;\u0026gt;(type)); } } public \u0026lt;T\u0026gt; boolean hasMapper(Class\u0026lt;T\u0026gt; type) { return knownMappers.containsKey(type); } // 包名注册 public void addMappers(String packageName) { // hutool工具包的scanner Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; mapperSet = ClassScanner.scanPackage(packageName); for (Class\u0026lt;?\u0026gt; mapperClass : mapperSet) { addMapper(mapperClass); } } } SqlSession\npublic interface SqlSession { \u0026lt;T\u0026gt; T selectOne(String statement); \u0026lt;T\u0026gt; T selectOne(String statement, Object parameter); \u0026lt;T\u0026gt; T getMapper(Class\u0026lt;T\u0026gt; type); } public class DefaultSqlSession implements SqlSession { private MapperRegistry mapperRegistry; public DefaultSqlSession(MapperRegistry mapperRegistry) { this.mapperRegistry = mapperRegistry; } // 暂无数据库连接 @Override public \u0026lt;T\u0026gt; T selectOne(String statement) { return (T) (\u0026#34;你被代理了！\u0026#34; + statement); } // 暂无数据库连接 @Override public \u0026lt;T\u0026gt; T selectOne(String statement, Object parameter) { return (T) (\u0026#34;你被代理了！\u0026#34; + \u0026#34;方法：\u0026#34; + statement + \u0026#34; 入参：\u0026#34; + parameter); } // 获取mapper proxy实例 @Override public \u0026lt;T\u0026gt; T getMapper(Class\u0026lt;T\u0026gt; type) { return mapperRegistry.getMapper(type, this); } } SqlSessionFactory\npublic interface SqlSessionFactory { SqlSession openSession(); } public class DefaultSqlSessionFactory implements SqlSessionFactory { private final MapperRegistry mapperRegistry; public DefaultSqlSessionFactory(MapperRegistry mapperRegistry) { this.mapperRegistry = mapperRegistry; } // 获取一个SqlSession实例 @Override public SqlSession openSession() { return new DefaultSqlSession(mapperRegistry); } } 测试类\n@Test public void test_MapperProxyFactory() { // 1. 注册 Mapper MapperRegistry registry = new MapperRegistry(); registry.addMappers(\u0026#34;cn.bugstack.mybatis.test.dao\u0026#34;); // 2. 从 SqlSession 工厂获取 Session SqlSessionFactory sqlSessionFactory = new DefaultSqlSessionFactory(registry); SqlSession sqlSession = sqlSessionFactory.openSession(); // 3. 获取映射器对象 IUserDao userDao = sqlSession.getMapper(IUserDao.class); // 4. 测试验证 String res = userDao.queryUserName(\u0026#34;10001\u0026#34;); logger.info(\u0026#34;测试结果：{}\u0026#34;, res); } 疑问\n注册机里面存放的是ProxyFactory，每一次使用时都需要new一个Proxy实例？？？\n是如何跟Spring结合起来的\n总结\nMapperRegistry扫描包生成MapperProxyFactory，存放在Map中 SqlSession ","date":"2022-06-08T00:22:03+08:00","permalink":"https://www.dmme2024.xyz/p/%E6%89%8B%E6%92%B8mybatis-02-%E5%AE%9E%E7%8E%B0%E6%98%A0%E5%B0%84%E5%99%A8%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E4%BD%BF%E7%94%A8/","title":"手撸Mybatis-02-实现映射器的注册和使用"},{"content":"Redis（测试hugo的帖子） 基本数据结构 RedisObject Redis对象头，所有Redis对象都有这个对象头\nstruct RedisObject { int4 type; // 4bits 类型 int4 encoding; // 4bits 编码方式 int24 lru; // 24bits LRU时间 int32 refcount; // 4bytes 引用计数 void *ptr; // 8bytes，64-bit system 指向对象值 } robj; encoding： 决定了对象的数据结构，比如是采用字典还是压缩链表等，如下\n类型 编码 对象 REDIS_STRING REDIS_ENCODING_INT 使用整数值实现的字符串对象 REDIS_STRING REDIS_ENCODING_RAW 使用简单动态字符串实现的字符串对象 REDIS_STRING REDIS_ENCODING_EMBSTR 使用embstr编码的简单动态字符串实现的字符串对象 REDIS_LIST REDIS_ENCODING_ZIPLIST 使用压缩列表实现的列表对象 REDIS_LIST REDIS_ENCODING_LINKENDLIST 使用双端链表实现的列表对象 REDIS_HASH REDIS_ENCODING_ZIPLIST 使用压缩列表实现的哈希对象 REDIS_HASH REDIS_ENCODING_HT 使用字典实现的哈希对象 REDIS_SET REDIS_ENCODING_INTSET 使用整数集合实现的集合对象 REDIS_SET REDIS_ENCODING_HT 使用字典实现的集合对象 REDIS_ZSET REDIS_ENCODING_ZIPLIST 使用压缩链表实现的有序集合对象 REDIS_ZSET REDIS_ENCODING_SKIPLIST 使用跳跃列表和字典实现的有序集合对象 LRU时间主要是为了根据lru的淘汰策略\nrefcount是记录引用次数，引用为0时就是可以回收的对象，此外，整数对象是共享的\nString 底层实现 SDS(Simple Dynamic String) 结构体\nstruct SDS\u0026lt;T\u0026gt; { T capacity;// 分配的数组容量 T len; // 实际字符串数组长度 byte flags; // 特殊标识位，不理睬它 byte[] content; // 数组内容 } 使用了泛型T，在字符串短的时候，可以采用byte和short表示，节省内存。\ncapacity变量记录字符串的分配的数组容量，不容易导致字符串操作溢出分配的内存区，比如合并之类的操作可以根据容量，避免字符串溢出分配的大小\nlen记录字符串实际长度，在C语言里面要获取字符串长度需要逐个遍历，O(N)的复杂度\n存储方式\n对象头说明\n存储主要有两种方式：embstr和raw，在字符串长度超过44时采用raw形式存储。\nembstr，申请一次内存最大64个字节，将RedisObject对象与SDS对象连续存放在一起，所以，RedisObject占用了16个字节（64位系统一个字节8\nbits），SDS结构体减去content占用3个字节，并且content末尾有个结束符\\0,所以在超过44bytes后，就需要将存储转换为raw。\nraw，申请两次内存（分配内存的单位都是2 4 8 \u0026hellip; 64），两个对象在内存里面不连续。\n扩容策略：小于1M 容量加倍再判断 超过1M，每次1M\n使用场景 存储的基本都是 整型、字符串，一般用来记录数据量，重复取用的字符串，比如访问量，验证码（不需要存入数据库）之类\nList 底层实现 ZipList\tQuickList\n元素比较少的时候直接使用ZipList，较多时，使用QuickList\n使用场景 要获取list里面的元素是很慢的，但是插入删除（头尾）一个元素是很快的。适合当作队列堆栈来使用。\n作为延时队列之类的\nHash 底层实现 struct dict { ... dictht ht[2]; // 两个hashtable } struct dictht { dictEntry** table; // 二维 long size; // 第一维数组的长度 long used; // hash表中的元素个数 ... } struct dictEntry { void* key; void* val; dictEntry* next; // 链接下一个entry } dict结构体中有两个 hashtable，正常是只有一个有值的，但是dict扩容缩容的时候，重新分配hashtable，然后渐进式搬迁。\ndictht二维，存储链表的头节点，链表则是具体的内容，因为是采用链地址（分桶）的方式解决hash冲突\n由于dict的扩容耗时大，O（N），采用渐进式rehash\n给ht[1]分配空间，维持一个索引计数器rehashidx\n在rehash期间，对dict字典执行的增删改查操作，顺带将ht[0]中rehashidx上的桶链迁移到ht[1]\n同时还有定时任务\n查找过程：根据hash函数，找到在哪个桶上，遍历这个桶\nhash函数：siphash\nhash攻击\n使用场景 跟Java hashmap差不多\nSet Set 特殊的dict，value都是null\n底层是字典和整数集合\nset集合只包含整数，并且数量不多时，使用整数集合实现，不预留空间 类似数组 升级int16-\u0026gt;int32-\u0026gt;int64\nZSet SkipList\nHash\nZipList 底层实现 struct ziplist\u0026lt;T\u0026gt; { int32 zlbytes; // 整个压缩列表占用字节数 int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点，倒着遍历 int16 zllength; // 元素个数 T[] entries; // 元素内容列表，挨个挨个紧凑存储 int8 zlend; // 标志压缩列表的结束，值恒为0xFF } struct entry { int\u0026lt;var\u0026gt; prevlen; // 前一个entry 的字节长度，倒着遍历，快速定位，长度小于254 一个字节 大于等于 5个字节（第一个字节标志位0xFE） int\u0026lt;var\u0026gt; encoding; // 元素类型编码，有一定的规则设计 optional byte[] content; // 元素内容 可选（比较小的整数直接放入了encoding后面） } ZipList没有冗余空间，每一次插入都需要用realloc拓展内存。有可能直接在原来的地址上增加，也有可能重新分配内存，拷贝过去，取决于内存分配器的算法，所以不适合存储太多。\n级联更新问题\nprevlen记录了前一元素的字节长度，如果前一元素长度变动使得prevlen范围超过254，就可能需要扩大/缩小prevlen的字节数，若是变动导致其他元素变动也超过这个范围，就会发生级联更新\nredis默认不处理需要缩小prevlen的情况，直接使用5个字节表示一个字节的内容\nQuickList 底层实现 struct ziplist_compressed { int32 size; byte[] compressed_data; } struct quicklistNode { quicklistNode* prev; quicklistNode* next; ziplist* zl; // 指向压缩列表 int32 size; // ziplist 的字节总数 int16 count; // ziplist 中的元素数量 int2 encoding; // 存储形式2bit，原生字节数组还是LZF 压缩存储 ... } struct quicklist { quicklistNode* head; quicklistNode* tail; long count; // 元素总数 int nodes; // ziplist 节点的个数 int compressDepth; // LZF 算法压缩深度 ... } quicklist默认单个ziplist长度位8k字节，超过就新建一个ziplist，这个长度由参数list-max-ziplist-size决定。\n结构体ziplist_compressed是多个ziplist经过LZF压缩算法后得到的，默认的压缩深度为0，也就是不压缩，可由配置参数list-compress-depth决定。\nListPack redis5.0引入，对ziplist的改进，目前发行版6.2还未完全替代，hash set在最新发布的代码已经替换成listpack，空间换时间\n底层实现 struct listpack\u0026lt;T\u0026gt; { int32 total_bytes;// 占用的总字节数 int16 size; // 元素个数 T[] entries; // 紧凑排列的元素列表 int8 end; // 同zlend 一样，恒为0xFF } struct lpentry { int\u0026lt;var\u0026gt; encoding; // 编码 optional byte[] content; int\u0026lt;var\u0026gt; length; // 当前元素的长度 } 相较于ziplist取消zltail_offset，可以根据total_bytes 跟 最后一个元素的长度 推断出来（根据编码解码可以得知最后一个元素的位置）\n对于级联更新，因为元素存储的是当前元素的长度，并不会影响到其他元素\nSkipList 底层实现 struct zslnode { string value; double score; zslnode*[] forwards; // 多层连接指针 zslnode* backward; // 回溯指针 } struct zsl { zslnode* header; // 跳跃列表头指针 int maxLevel; // 跳跃列表当前的最高层 map\u0026lt;string, zslnode*\u0026gt; ht; // hash 结构的所有键值对 } struct zslforward { zslnode* item; long span; // 跨度 } 详细点击：skiplist详解\n通俗了说，每增加一个节点，随机产生一个层数，如此，插入操作只需要修改节点前后指针（比如小于前一个节点，将指向前一个节点的指定都指向插入节点），每一个层级跨越一定的节点数（是按照层数，比如4层，上面的指针每次就跨越4个节点？？）\n查找过程\n找到比我小的最后一个元素，然后降一个层级继续查找。例子，如下图\n插入过程 \u0026hellip; 删除过程 \u0026hellip; 更新过程 \u0026hellip; 计算一个元素排名的时候，将经过的节点span加起来，就能得到排名值\nRaw 主要是在redis stream里面用于存储消息队列\n数据库功能 集群分布式功能 拓展模块 注意点 ","date":"2022-06-05T00:22:03+08:00","permalink":"https://www.dmme2024.xyz/p/redis/","title":"Redis"},{"content":"设计图\n工程结构\nmybatis-step-03 └── src ├── main │ └── java │ └── cn.bugstack.mybatis │ ├── binding │ │ ├── MapperMethod.java // 执行具体操作 │ │ ├── MapperProxy.java // 代理类 │ │ ├── MapperProxyFactory.java // 代理工厂 │ │ └── MapperRegistry.java // Mapper注册机，扫描Mapper接口 │ ├── builder │ │ ├── xml │ │ │ └── XMLConfigBuilder.java // 解析Mapper.xml 将sql封装成MappedStatement │ │ └── BaseBuilder.java │ ├── io │ │ └── Resources.java // IO读取文件 │ ├── mapping │ │ ├── MappedStatement.java // 封装的SQL │ │ └── SqlCommandType.java // Enum │ └── session │ ├── defaults │ │ ├── DefaultSqlSession.java │ │ └── DefaultSqlSessionFactory.java │ ├── Configuration.java // 配置类 里面有Mapper注册机 封装好的MappedStatement │ ├── SqlSession.java // 将SQL提交给数据库？ │ ├── SqlSessionFactory.java // 工厂类 │ └── SqlSessionFactoryBuilder.java // 用Configuration初始化SqlSessionFactory └── test // 测试 ├── java │ └── cn.bugstack.mybatis.test.dao │ ├── dao │ │ └── IUserDao.java │ ├── po │ │ └── User.java │ └── ApiTest.java └── resources ├── mapper │ └──User_Mapper.xml └── mybatis-config-datasource.xml 分析\nXMLConfigBuilder解析Mapper.xml 跟 config.xml，将SQL语句转换为MappedStatement，具体分析见下期文章。\n","date":"0001-01-01T00:00:00Z","permalink":"https://www.dmme2024.xyz/p/%E6%89%8B%E6%92%B8mybatis-03-xml%E7%9A%84%E8%A7%A3%E6%9E%90/","title":"手撸Mybatis-03-XML的解析"},{"content":"解析 ","date":"0001-01-01T00:00:00Z","permalink":"https://www.dmme2024.xyz/p/%E6%89%8B%E6%92%B8mybatis-04-%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E8%A7%A3%E6%9E%90%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/","title":"手撸Mybatis-04-数据源的解析、创建和使用"}]